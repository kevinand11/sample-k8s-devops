// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s'
import { Construct } from 'constructs'


/**
 * AccessControlPolicy defines an access control policy.
 *
 * @schema AccessControlPolicy
 */
export class AccessControlPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessControlPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'AccessControlPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AccessControlPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessControlPolicyProps = {}): any {
    return {
      ...AccessControlPolicy.GVK,
      ...toJson_AccessControlPolicyProps(props),
    }
  }

  /**
   * Defines a "AccessControlPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessControlPolicyProps = {}) {
    super(scope, id, {
      ...AccessControlPolicy.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...AccessControlPolicy.GVK,
      ...toJson_AccessControlPolicyProps(resolved),
    }
  }
}

/**
 * AccessControlPolicy defines an access control policy.
 *
 * @schema AccessControlPolicy
 */
export interface AccessControlPolicyProps {
  /**
   * @schema AccessControlPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessControlPolicySpec configures an access control policy.
   *
   * @schema AccessControlPolicy#spec
   */
  readonly spec?: AccessControlPolicySpec;

}

/**
 * Converts an object of type 'AccessControlPolicyProps' to JSON representation.
 */
 
export function toJson_AccessControlPolicyProps(obj: AccessControlPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessControlPolicySpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicySpec configures an access control policy.
 *
 * @schema AccessControlPolicySpec
 */
export interface AccessControlPolicySpec {
  /**
   * AccessControlPolicyAPIKey configure an APIKey control policy.
   *
   * @schema AccessControlPolicySpec#apiKey
   */
  readonly apiKey?: AccessControlPolicySpecApiKey;

  /**
   * AccessControlPolicyBasicAuth holds the HTTP basic authentication configuration.
   *
   * @schema AccessControlPolicySpec#basicAuth
   */
  readonly basicAuth?: AccessControlPolicySpecBasicAuth;

  /**
   * AccessControlPolicyJWT configures a JWT access control policy.
   *
   * @schema AccessControlPolicySpec#jwt
   */
  readonly jwt?: AccessControlPolicySpecJwt;

  /**
   * AccessControlOAuthIntro configures an OAuth 2.0 Token Introspection access control policy.
   *
   * @schema AccessControlPolicySpec#oAuthIntro
   */
  readonly oAuthIntro?: AccessControlPolicySpecOAuthIntro;

  /**
   * AccessControlPolicyOIDC holds the OIDC authentication configuration.
   *
   * @schema AccessControlPolicySpec#oidc
   */
  readonly oidc?: AccessControlPolicySpecOidc;

  /**
   * AccessControlPolicyOIDCGoogle holds the Google OIDC authentication configuration.
   *
   * @schema AccessControlPolicySpec#oidcGoogle
   */
  readonly oidcGoogle?: AccessControlPolicySpecOidcGoogle;

}

/**
 * Converts an object of type 'AccessControlPolicySpec' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpec(obj: AccessControlPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiKey': toJson_AccessControlPolicySpecApiKey(obj.apiKey),
    'basicAuth': toJson_AccessControlPolicySpecBasicAuth(obj.basicAuth),
    'jwt': toJson_AccessControlPolicySpecJwt(obj.jwt),
    'oAuthIntro': toJson_AccessControlPolicySpecOAuthIntro(obj.oAuthIntro),
    'oidc': toJson_AccessControlPolicySpecOidc(obj.oidc),
    'oidcGoogle': toJson_AccessControlPolicySpecOidcGoogle(obj.oidcGoogle),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyAPIKey configure an APIKey control policy.
 *
 * @schema AccessControlPolicySpecApiKey
 */
export interface AccessControlPolicySpecApiKey {
  /**
   * ForwardHeaders instructs the middleware to forward key metadata as header values upon successful authentication.
   *
   * @schema AccessControlPolicySpecApiKey#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * KeySource defines how to extract API keys from requests.
   *
   * @schema AccessControlPolicySpecApiKey#keySource
   */
  readonly keySource: AccessControlPolicySpecApiKeyKeySource;

  /**
   * Keys define the set of authorized keys to access a protected resource.
   *
   * @schema AccessControlPolicySpecApiKey#keys
   */
  readonly keys?: AccessControlPolicySpecApiKeyKeys[];

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKey' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecApiKey(obj: AccessControlPolicySpecApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keySource': toJson_AccessControlPolicySpecApiKeyKeySource(obj.keySource),
    'keys': obj.keys?.map((y) => toJson_AccessControlPolicySpecApiKeyKeys(y)),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyBasicAuth holds the HTTP basic authentication configuration.
 *
 * @schema AccessControlPolicySpecBasicAuth
 */
export interface AccessControlPolicySpecBasicAuth {
  /**
   * @schema AccessControlPolicySpecBasicAuth#forwardUsernameHeader
   */
  readonly forwardUsernameHeader?: string;

  /**
   * @schema AccessControlPolicySpecBasicAuth#realm
   */
  readonly realm?: string;

  /**
   * @schema AccessControlPolicySpecBasicAuth#stripAuthorizationHeader
   */
  readonly stripAuthorizationHeader?: boolean;

  /**
   * @schema AccessControlPolicySpecBasicAuth#users
   */
  readonly users?: string[];

}

/**
 * Converts an object of type 'AccessControlPolicySpecBasicAuth' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecBasicAuth(obj: AccessControlPolicySpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'forwardUsernameHeader': obj.forwardUsernameHeader,
    'realm': obj.realm,
    'stripAuthorizationHeader': obj.stripAuthorizationHeader,
    'users': obj.users?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyJWT configures a JWT access control policy.
 *
 * @schema AccessControlPolicySpecJwt
 */
export interface AccessControlPolicySpecJwt {
  /**
   * @schema AccessControlPolicySpecJwt#claims
   */
  readonly claims?: string;

  /**
   * @schema AccessControlPolicySpecJwt#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecJwt#jwksFile
   */
  readonly jwksFile?: string;

  /**
   * @schema AccessControlPolicySpecJwt#jwksUrl
   */
  readonly jwksUrl?: string;

  /**
   * @schema AccessControlPolicySpecJwt#publicKey
   */
  readonly publicKey?: string;

  /**
   * @schema AccessControlPolicySpecJwt#signingSecret
   */
  readonly signingSecret?: string;

  /**
   * @schema AccessControlPolicySpecJwt#signingSecretBase64Encoded
   */
  readonly signingSecretBase64Encoded?: boolean;

  /**
   * @schema AccessControlPolicySpecJwt#stripAuthorizationHeader
   */
  readonly stripAuthorizationHeader?: boolean;

  /**
   * @schema AccessControlPolicySpecJwt#tokenQueryKey
   */
  readonly tokenQueryKey?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecJwt' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecJwt(obj: AccessControlPolicySpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'claims': obj.claims,
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'jwksFile': obj.jwksFile,
    'jwksUrl': obj.jwksUrl,
    'publicKey': obj.publicKey,
    'signingSecret': obj.signingSecret,
    'signingSecretBase64Encoded': obj.signingSecretBase64Encoded,
    'stripAuthorizationHeader': obj.stripAuthorizationHeader,
    'tokenQueryKey': obj.tokenQueryKey,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlOAuthIntro configures an OAuth 2.0 Token Introspection access control policy.
 *
 * @schema AccessControlPolicySpecOAuthIntro
 */
export interface AccessControlPolicySpecOAuthIntro {
  /**
   * @schema AccessControlPolicySpecOAuthIntro#claims
   */
  readonly claims?: string;

  /**
   * AccessControlOAuthIntroClientConfig configures the OAuth 2.0 client for issuing token introspection requests.
   *
   * @schema AccessControlPolicySpecOAuthIntro#clientConfig
   */
  readonly clientConfig: AccessControlPolicySpecOAuthIntroClientConfig;

  /**
   * @schema AccessControlPolicySpecOAuthIntro#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * TokenSource describes how to extract tokens from HTTP requests.
   * If multiple sources are set, the order is the following: header > query > cookie.
   *
   * @schema AccessControlPolicySpecOAuthIntro#tokenSource
   */
  readonly tokenSource: AccessControlPolicySpecOAuthIntroTokenSource;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntro' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOAuthIntro(obj: AccessControlPolicySpecOAuthIntro | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'claims': obj.claims,
    'clientConfig': toJson_AccessControlPolicySpecOAuthIntroClientConfig(obj.clientConfig),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tokenSource': toJson_AccessControlPolicySpecOAuthIntroTokenSource(obj.tokenSource),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyOIDC holds the OIDC authentication configuration.
 *
 * @schema AccessControlPolicySpecOidc
 */
export interface AccessControlPolicySpecOidc {
  /**
   * @schema AccessControlPolicySpecOidc#authParams
   */
  readonly authParams?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidc#claims
   */
  readonly claims?: string;

  /**
   * @schema AccessControlPolicySpecOidc#clientId
   */
  readonly clientId?: string;

  /**
   * @schema AccessControlPolicySpecOidc#disableAuthRedirectionPaths
   */
  readonly disableAuthRedirectionPaths?: string[];

  /**
   * @schema AccessControlPolicySpecOidc#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidc#issuer
   */
  readonly issuer?: string;

  /**
   * @schema AccessControlPolicySpecOidc#logoutUrl
   */
  readonly logoutUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidc#redirectUrl
   */
  readonly redirectUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidc#scopes
   */
  readonly scopes?: string[];

  /**
   * SecretReference represents a Secret Reference. It has enough information to retrieve secret
   * in any namespace
   *
   * @schema AccessControlPolicySpecOidc#secret
   */
  readonly secret?: AccessControlPolicySpecOidcSecret;

  /**
   * Session holds session configuration.
   *
   * @schema AccessControlPolicySpecOidc#session
   */
  readonly session?: AccessControlPolicySpecOidcSession;

  /**
   * StateCookie holds state cookie configuration.
   *
   * @schema AccessControlPolicySpecOidc#stateCookie
   */
  readonly stateCookie?: AccessControlPolicySpecOidcStateCookie;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidc' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidc(obj: AccessControlPolicySpecOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'authParams': ((obj.authParams) === undefined) ? undefined : (Object.entries(obj.authParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'claims': obj.claims,
    'clientId': obj.clientId,
    'disableAuthRedirectionPaths': obj.disableAuthRedirectionPaths?.map((y) => y),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'issuer': obj.issuer,
    'logoutUrl': obj.logoutUrl,
    'redirectUrl': obj.redirectUrl,
    'scopes': obj.scopes?.map((y) => y),
    'secret': toJson_AccessControlPolicySpecOidcSecret(obj.secret),
    'session': toJson_AccessControlPolicySpecOidcSession(obj.session),
    'stateCookie': toJson_AccessControlPolicySpecOidcStateCookie(obj.stateCookie),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyOIDCGoogle holds the Google OIDC authentication configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogle
 */
export interface AccessControlPolicySpecOidcGoogle {
  /**
   * @schema AccessControlPolicySpecOidcGoogle#authParams
   */
  readonly authParams?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidcGoogle#clientId
   */
  readonly clientId?: string;

  /**
   * Emails are the allowed emails to connect.
   *
   * @schema AccessControlPolicySpecOidcGoogle#emails
   */
  readonly emails?: string[];

  /**
   * @schema AccessControlPolicySpecOidcGoogle#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidcGoogle#logoutUrl
   */
  readonly logoutUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogle#redirectUrl
   */
  readonly redirectUrl?: string;

  /**
   * SecretReference represents a Secret Reference. It has enough information to retrieve secret
   * in any namespace
   *
   * @schema AccessControlPolicySpecOidcGoogle#secret
   */
  readonly secret?: AccessControlPolicySpecOidcGoogleSecret;

  /**
   * Session holds session configuration.
   *
   * @schema AccessControlPolicySpecOidcGoogle#session
   */
  readonly session?: AccessControlPolicySpecOidcGoogleSession;

  /**
   * StateCookie holds state cookie configuration.
   *
   * @schema AccessControlPolicySpecOidcGoogle#stateCookie
   */
  readonly stateCookie?: AccessControlPolicySpecOidcGoogleStateCookie;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogle' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcGoogle(obj: AccessControlPolicySpecOidcGoogle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'authParams': ((obj.authParams) === undefined) ? undefined : (Object.entries(obj.authParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'clientId': obj.clientId,
    'emails': obj.emails?.map((y) => y),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logoutUrl': obj.logoutUrl,
    'redirectUrl': obj.redirectUrl,
    'secret': toJson_AccessControlPolicySpecOidcGoogleSecret(obj.secret),
    'session': toJson_AccessControlPolicySpecOidcGoogleSession(obj.session),
    'stateCookie': toJson_AccessControlPolicySpecOidcGoogleStateCookie(obj.stateCookie),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * KeySource defines how to extract API keys from requests.
 *
 * @schema AccessControlPolicySpecApiKeyKeySource
 */
export interface AccessControlPolicySpecApiKeyKeySource {
  /**
   * Cookie is the name of a cookie.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#cookie
   */
  readonly cookie?: string;

  /**
   * Header is the name of a header.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#header
   */
  readonly header?: string;

  /**
   * HeaderAuthScheme sets an optional auth scheme when Header is set to "Authorization".
   * If set, this scheme is removed from the token, and all requests not including it are dropped.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#headerAuthScheme
   */
  readonly headerAuthScheme?: string;

  /**
   * Query is the name of a query parameter.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKeyKeySource' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecApiKeyKeySource(obj: AccessControlPolicySpecApiKeyKeySource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'cookie': obj.cookie,
    'header': obj.header,
    'headerAuthScheme': obj.headerAuthScheme,
    'query': obj.query,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlPolicyAPIKeyKey defines an API key.
 *
 * @schema AccessControlPolicySpecApiKeyKeys
 */
export interface AccessControlPolicySpecApiKeyKeys {
  /**
   * ID is the unique identifier of the key.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#id
   */
  readonly id: string;

  /**
   * Metadata holds arbitrary metadata for this key, can be used by ForwardHeaders.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Value is the SHAKE-256 hash (using 64 bytes) of the API key.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKeyKeys' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecApiKeyKeys(obj: AccessControlPolicySpecApiKeyKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'id': obj.id,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'value': obj.value,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AccessControlOAuthIntroClientConfig configures the OAuth 2.0 client for issuing token introspection requests.
 *
 * @schema AccessControlPolicySpecOAuthIntroClientConfig
 */
export interface AccessControlPolicySpecOAuthIntroClientConfig {
  /**
   * Headers to set when sending requests to the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MaxRetries defines the number of retries for introspection requests.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * TimeoutSeconds configures the maximum amount of seconds to wait before giving up on requests.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * TLS configures TLS communication with the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#tls
   */
  readonly tls?: AccessControlPolicySpecOAuthIntroClientConfigTls;

  /**
   * TokenTypeHint is a hint to pass to the Authorization Server.
   * See https://tools.ietf.org/html/rfc7662#section-2.1 for more information.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#tokenTypeHint
   */
  readonly tokenTypeHint?: string;

  /**
   * URL of the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroClientConfig' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOAuthIntroClientConfig(obj: AccessControlPolicySpecOAuthIntroClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maxRetries': obj.maxRetries,
    'timeoutSeconds': obj.timeoutSeconds,
    'tls': toJson_AccessControlPolicySpecOAuthIntroClientConfigTls(obj.tls),
    'tokenTypeHint': obj.tokenTypeHint,
    'url': obj.url,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * TokenSource describes how to extract tokens from HTTP requests.
 * If multiple sources are set, the order is the following: header > query > cookie.
 *
 * @schema AccessControlPolicySpecOAuthIntroTokenSource
 */
export interface AccessControlPolicySpecOAuthIntroTokenSource {
  /**
   * Cookie is the name of a cookie.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#cookie
   */
  readonly cookie?: string;

  /**
   * Header is the name of a header.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#header
   */
  readonly header?: string;

  /**
   * HeaderAuthScheme sets an optional auth scheme when Header is set to "Authorization".
   * If set, this scheme is removed from the token, and all requests not including it are dropped.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#headerAuthScheme
   */
  readonly headerAuthScheme?: string;

  /**
   * Query is the name of a query parameter.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroTokenSource' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOAuthIntroTokenSource(obj: AccessControlPolicySpecOAuthIntroTokenSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'cookie': obj.cookie,
    'header': obj.header,
    'headerAuthScheme': obj.headerAuthScheme,
    'query': obj.query,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 *
 * @schema AccessControlPolicySpecOidcSecret
 */
export interface AccessControlPolicySpecOidcSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema AccessControlPolicySpecOidcSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema AccessControlPolicySpecOidcSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcSecret' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcSecret(obj: AccessControlPolicySpecOidcSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Session holds session configuration.
 *
 * @schema AccessControlPolicySpecOidcSession
 */
export interface AccessControlPolicySpecOidcSession {
  /**
   * @schema AccessControlPolicySpecOidcSession#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#refresh
   */
  readonly refresh?: boolean;

  /**
   * @schema AccessControlPolicySpecOidcSession#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcSession' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcSession(obj: AccessControlPolicySpecOidcSession | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'refresh': obj.refresh,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * StateCookie holds state cookie configuration.
 *
 * @schema AccessControlPolicySpecOidcStateCookie
 */
export interface AccessControlPolicySpecOidcStateCookie {
  /**
   * @schema AccessControlPolicySpecOidcStateCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcStateCookie' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcStateCookie(obj: AccessControlPolicySpecOidcStateCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 *
 * @schema AccessControlPolicySpecOidcGoogleSecret
 */
export interface AccessControlPolicySpecOidcGoogleSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema AccessControlPolicySpecOidcGoogleSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema AccessControlPolicySpecOidcGoogleSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleSecret' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcGoogleSecret(obj: AccessControlPolicySpecOidcGoogleSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Session holds session configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogleSession
 */
export interface AccessControlPolicySpecOidcGoogleSession {
  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#refresh
   */
  readonly refresh?: boolean;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleSession' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcGoogleSession(obj: AccessControlPolicySpecOidcGoogleSession | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'refresh': obj.refresh,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * StateCookie holds state cookie configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogleStateCookie
 */
export interface AccessControlPolicySpecOidcGoogleStateCookie {
  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleStateCookie' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOidcGoogleStateCookie(obj: AccessControlPolicySpecOidcGoogleStateCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * TLS configures TLS communication with the Authorization Server.
 *
 * @schema AccessControlPolicySpecOAuthIntroClientConfigTls
 */
export interface AccessControlPolicySpecOAuthIntroClientConfigTls {
  /**
   * CA sets the CA bundle used to sign the Authorization Server certificate.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfigTls#ca
   */
  readonly ca?: string;

  /**
   * InsecureSkipVerify skips the Authorization Server certificate validation.
   * For testing purposes only, do not use in production.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfigTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroClientConfigTls' to JSON representation.
 */
 
export function toJson_AccessControlPolicySpecOAuthIntroClientConfigTls(obj: AccessControlPolicySpecOAuthIntroClientConfigTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'ca': obj.ca,
    'insecureSkipVerify': obj.insecureSkipVerify,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * AIService is a Kubernetes-like Service to interact with a text-based LLM provider. It defines the parameters and credentials required to interact with various LLM providers.
 *
 * @schema AIService
 */
export class AiService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AIService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'AIService',
  }

  /**
   * Renders a Kubernetes manifest for "AIService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AiServiceProps = {}): any {
    return {
      ...AiService.GVK,
      ...toJson_AiServiceProps(props),
    }
  }

  /**
   * Defines a "AIService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AiServiceProps = {}) {
    super(scope, id, {
      ...AiService.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...AiService.GVK,
      ...toJson_AiServiceProps(resolved),
    }
  }
}

/**
 * AIService is a Kubernetes-like Service to interact with a text-based LLM provider. It defines the parameters and credentials required to interact with various LLM providers.
 *
 * @schema AIService
 */
export interface AiServiceProps {
  /**
   * @schema AIService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this AIService.
   *
   * @schema AIService#spec
   */
  readonly spec?: AiServiceSpec;

}

/**
 * Converts an object of type 'AiServiceProps' to JSON representation.
 */
 
export function toJson_AiServiceProps(obj: AiServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AiServiceSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this AIService.
 *
 * @schema AiServiceSpec
 */
export interface AiServiceSpec {
  /**
   * Anthropic configures Anthropic backend.
   *
   * @schema AiServiceSpec#anthropic
   */
  readonly anthropic?: AiServiceSpecAnthropic;

  /**
   * AzureOpenAI configures AzureOpenAI.
   *
   * @schema AiServiceSpec#azureOpenai
   */
  readonly azureOpenai?: AiServiceSpecAzureOpenai;

  /**
   * Bedrock configures Bedrock backend.
   *
   * @schema AiServiceSpec#bedrock
   */
  readonly bedrock?: AiServiceSpecBedrock;

  /**
   * Cohere configures Cohere backend.
   *
   * @schema AiServiceSpec#cohere
   */
  readonly cohere?: AiServiceSpecCohere;

  /**
   * DeepSeek configures DeepSeek.
   *
   * @schema AiServiceSpec#deepSeek
   */
  readonly deepSeek?: AiServiceSpecDeepSeek;

  /**
   * Gemini configures Gemini backend.
   *
   * @schema AiServiceSpec#gemini
   */
  readonly gemini?: AiServiceSpecGemini;

  /**
   * Mistral configures Mistral AI backend.
   *
   * @schema AiServiceSpec#mistral
   */
  readonly mistral?: AiServiceSpecMistral;

  /**
   * Ollama configures Ollama backend.
   *
   * @schema AiServiceSpec#ollama
   */
  readonly ollama?: AiServiceSpecOllama;

  /**
   * OpenAI configures OpenAI.
   *
   * @schema AiServiceSpec#openai
   */
  readonly openai?: AiServiceSpecOpenai;

  /**
   * QWen configures QWen.
   *
   * @schema AiServiceSpec#qWen
   */
  readonly qWen?: AiServiceSpecQWen;

}

/**
 * Converts an object of type 'AiServiceSpec' to JSON representation.
 */
 
export function toJson_AiServiceSpec(obj: AiServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'anthropic': toJson_AiServiceSpecAnthropic(obj.anthropic),
    'azureOpenai': toJson_AiServiceSpecAzureOpenai(obj.azureOpenai),
    'bedrock': toJson_AiServiceSpecBedrock(obj.bedrock),
    'cohere': toJson_AiServiceSpecCohere(obj.cohere),
    'deepSeek': toJson_AiServiceSpecDeepSeek(obj.deepSeek),
    'gemini': toJson_AiServiceSpecGemini(obj.gemini),
    'mistral': toJson_AiServiceSpecMistral(obj.mistral),
    'ollama': toJson_AiServiceSpecOllama(obj.ollama),
    'openai': toJson_AiServiceSpecOpenai(obj.openai),
    'qWen': toJson_AiServiceSpecQWen(obj.qWen),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Anthropic configures Anthropic backend.
 *
 * @schema AiServiceSpecAnthropic
 */
export interface AiServiceSpecAnthropic {
  /**
   * @schema AiServiceSpecAnthropic#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecAnthropic#params
   */
  readonly params?: AiServiceSpecAnthropicParams;

  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecAnthropic#token
   */
  readonly token?: AiServiceSpecAnthropicToken;

}

/**
 * Converts an object of type 'AiServiceSpecAnthropic' to JSON representation.
 */
 
export function toJson_AiServiceSpecAnthropic(obj: AiServiceSpecAnthropic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecAnthropicParams(obj.params),
    'token': toJson_AiServiceSpecAnthropicToken(obj.token),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * AzureOpenAI configures AzureOpenAI.
 *
 * @schema AiServiceSpecAzureOpenai
 */
export interface AiServiceSpecAzureOpenai {
  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecAzureOpenai#apiKeySecret
   */
  readonly apiKeySecret?: AiServiceSpecAzureOpenaiApiKeySecret;

  /**
   * @schema AiServiceSpecAzureOpenai#baseUrl
   */
  readonly baseUrl: string;

  /**
   * @schema AiServiceSpecAzureOpenai#deploymentName
   */
  readonly deploymentName: string;

  /**
   * @schema AiServiceSpecAzureOpenai#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecAzureOpenai#params
   */
  readonly params?: AiServiceSpecAzureOpenaiParams;

}

/**
 * Converts an object of type 'AiServiceSpecAzureOpenai' to JSON representation.
 */
 
export function toJson_AiServiceSpecAzureOpenai(obj: AiServiceSpecAzureOpenai | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiKeySecret': toJson_AiServiceSpecAzureOpenaiApiKeySecret(obj.apiKeySecret),
    'baseUrl': obj.baseUrl,
    'deploymentName': obj.deploymentName,
    'model': obj.model,
    'params': toJson_AiServiceSpecAzureOpenaiParams(obj.params),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Bedrock configures Bedrock backend.
 *
 * @schema AiServiceSpecBedrock
 */
export interface AiServiceSpecBedrock {
  /**
   * @schema AiServiceSpecBedrock#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecBedrock#params
   */
  readonly params?: AiServiceSpecBedrockParams;

  /**
   * @schema AiServiceSpecBedrock#region
   */
  readonly region?: string;

  /**
   * @schema AiServiceSpecBedrock#systemMessage
   */
  readonly systemMessage?: boolean;

}

/**
 * Converts an object of type 'AiServiceSpecBedrock' to JSON representation.
 */
 
export function toJson_AiServiceSpecBedrock(obj: AiServiceSpecBedrock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecBedrockParams(obj.params),
    'region': obj.region,
    'systemMessage': obj.systemMessage,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Cohere configures Cohere backend.
 *
 * @schema AiServiceSpecCohere
 */
export interface AiServiceSpecCohere {
  /**
   * @schema AiServiceSpecCohere#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecCohere#params
   */
  readonly params?: AiServiceSpecCohereParams;

  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecCohere#token
   */
  readonly token?: AiServiceSpecCohereToken;

}

/**
 * Converts an object of type 'AiServiceSpecCohere' to JSON representation.
 */
 
export function toJson_AiServiceSpecCohere(obj: AiServiceSpecCohere | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecCohereParams(obj.params),
    'token': toJson_AiServiceSpecCohereToken(obj.token),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * DeepSeek configures DeepSeek.
 *
 * @schema AiServiceSpecDeepSeek
 */
export interface AiServiceSpecDeepSeek {
  /**
   * @schema AiServiceSpecDeepSeek#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * @schema AiServiceSpecDeepSeek#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecDeepSeek#params
   */
  readonly params?: AiServiceSpecDeepSeekParams;

  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecDeepSeek#token
   */
  readonly token?: AiServiceSpecDeepSeekToken;

}

/**
 * Converts an object of type 'AiServiceSpecDeepSeek' to JSON representation.
 */
 
export function toJson_AiServiceSpecDeepSeek(obj: AiServiceSpecDeepSeek | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'baseUrl': obj.baseUrl,
    'model': obj.model,
    'params': toJson_AiServiceSpecDeepSeekParams(obj.params),
    'token': toJson_AiServiceSpecDeepSeekToken(obj.token),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Gemini configures Gemini backend.
 *
 * @schema AiServiceSpecGemini
 */
export interface AiServiceSpecGemini {
  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecGemini#apiKey
   */
  readonly apiKey?: AiServiceSpecGeminiApiKey;

  /**
   * @schema AiServiceSpecGemini#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecGemini#params
   */
  readonly params?: AiServiceSpecGeminiParams;

}

/**
 * Converts an object of type 'AiServiceSpecGemini' to JSON representation.
 */
 
export function toJson_AiServiceSpecGemini(obj: AiServiceSpecGemini | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiKey': toJson_AiServiceSpecGeminiApiKey(obj.apiKey),
    'model': obj.model,
    'params': toJson_AiServiceSpecGeminiParams(obj.params),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Mistral configures Mistral AI backend.
 *
 * @schema AiServiceSpecMistral
 */
export interface AiServiceSpecMistral {
  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecMistral#apiKey
   */
  readonly apiKey?: AiServiceSpecMistralApiKey;

  /**
   * @schema AiServiceSpecMistral#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecMistral#params
   */
  readonly params?: AiServiceSpecMistralParams;

}

/**
 * Converts an object of type 'AiServiceSpecMistral' to JSON representation.
 */
 
export function toJson_AiServiceSpecMistral(obj: AiServiceSpecMistral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiKey': toJson_AiServiceSpecMistralApiKey(obj.apiKey),
    'model': obj.model,
    'params': toJson_AiServiceSpecMistralParams(obj.params),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Ollama configures Ollama backend.
 *
 * @schema AiServiceSpecOllama
 */
export interface AiServiceSpecOllama {
  /**
   * @schema AiServiceSpecOllama#baseUrl
   */
  readonly baseUrl: string;

  /**
   * @schema AiServiceSpecOllama#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecOllama#params
   */
  readonly params?: AiServiceSpecOllamaParams;

}

/**
 * Converts an object of type 'AiServiceSpecOllama' to JSON representation.
 */
 
export function toJson_AiServiceSpecOllama(obj: AiServiceSpecOllama | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'baseUrl': obj.baseUrl,
    'model': obj.model,
    'params': toJson_AiServiceSpecOllamaParams(obj.params),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OpenAI configures OpenAI.
 *
 * @schema AiServiceSpecOpenai
 */
export interface AiServiceSpecOpenai {
  /**
   * @schema AiServiceSpecOpenai#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * @schema AiServiceSpecOpenai#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecOpenai#params
   */
  readonly params?: AiServiceSpecOpenaiParams;

  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecOpenai#token
   */
  readonly token?: AiServiceSpecOpenaiToken;

}

/**
 * Converts an object of type 'AiServiceSpecOpenai' to JSON representation.
 */
 
export function toJson_AiServiceSpecOpenai(obj: AiServiceSpecOpenai | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'baseUrl': obj.baseUrl,
    'model': obj.model,
    'params': toJson_AiServiceSpecOpenaiParams(obj.params),
    'token': toJson_AiServiceSpecOpenaiToken(obj.token),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * QWen configures QWen.
 *
 * @schema AiServiceSpecQWen
 */
export interface AiServiceSpecQWen {
  /**
   * @schema AiServiceSpecQWen#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * @schema AiServiceSpecQWen#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecQWen#params
   */
  readonly params?: AiServiceSpecQWenParams;

  /**
   * SecretReference references a kubernetes secret.
   *
   * @schema AiServiceSpecQWen#token
   */
  readonly token?: AiServiceSpecQWenToken;

}

/**
 * Converts an object of type 'AiServiceSpecQWen' to JSON representation.
 */
 
export function toJson_AiServiceSpecQWen(obj: AiServiceSpecQWen | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'baseUrl': obj.baseUrl,
    'model': obj.model,
    'params': toJson_AiServiceSpecQWenParams(obj.params),
    'token': toJson_AiServiceSpecQWenToken(obj.token),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecAnthropicParams
 */
export interface AiServiceSpecAnthropicParams {
  /**
   * @schema AiServiceSpecAnthropicParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecAnthropicParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecAnthropicParams(obj: AiServiceSpecAnthropicParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecAnthropicToken
 */
export interface AiServiceSpecAnthropicToken {
  /**
   * @schema AiServiceSpecAnthropicToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecAnthropicToken' to JSON representation.
 */
 
export function toJson_AiServiceSpecAnthropicToken(obj: AiServiceSpecAnthropicToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecAzureOpenaiApiKeySecret
 */
export interface AiServiceSpecAzureOpenaiApiKeySecret {
  /**
   * @schema AiServiceSpecAzureOpenaiApiKeySecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecAzureOpenaiApiKeySecret' to JSON representation.
 */
 
export function toJson_AiServiceSpecAzureOpenaiApiKeySecret(obj: AiServiceSpecAzureOpenaiApiKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecAzureOpenaiParams
 */
export interface AiServiceSpecAzureOpenaiParams {
  /**
   * @schema AiServiceSpecAzureOpenaiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecAzureOpenaiParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecAzureOpenaiParams(obj: AiServiceSpecAzureOpenaiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecBedrockParams
 */
export interface AiServiceSpecBedrockParams {
  /**
   * @schema AiServiceSpecBedrockParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecBedrockParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecBedrockParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecBedrockParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecBedrockParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecBedrockParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecBedrockParams(obj: AiServiceSpecBedrockParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecCohereParams
 */
export interface AiServiceSpecCohereParams {
  /**
   * @schema AiServiceSpecCohereParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecCohereParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecCohereParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecCohereParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecCohereParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecCohereParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecCohereParams(obj: AiServiceSpecCohereParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecCohereToken
 */
export interface AiServiceSpecCohereToken {
  /**
   * @schema AiServiceSpecCohereToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecCohereToken' to JSON representation.
 */
 
export function toJson_AiServiceSpecCohereToken(obj: AiServiceSpecCohereToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecDeepSeekParams
 */
export interface AiServiceSpecDeepSeekParams {
  /**
   * @schema AiServiceSpecDeepSeekParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecDeepSeekParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecDeepSeekParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecDeepSeekParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecDeepSeekParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecDeepSeekParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecDeepSeekParams(obj: AiServiceSpecDeepSeekParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecDeepSeekToken
 */
export interface AiServiceSpecDeepSeekToken {
  /**
   * @schema AiServiceSpecDeepSeekToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecDeepSeekToken' to JSON representation.
 */
 
export function toJson_AiServiceSpecDeepSeekToken(obj: AiServiceSpecDeepSeekToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecGeminiApiKey
 */
export interface AiServiceSpecGeminiApiKey {
  /**
   * @schema AiServiceSpecGeminiApiKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecGeminiApiKey' to JSON representation.
 */
 
export function toJson_AiServiceSpecGeminiApiKey(obj: AiServiceSpecGeminiApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecGeminiParams
 */
export interface AiServiceSpecGeminiParams {
  /**
   * @schema AiServiceSpecGeminiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecGeminiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecGeminiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecGeminiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecGeminiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecGeminiParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecGeminiParams(obj: AiServiceSpecGeminiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecMistralApiKey
 */
export interface AiServiceSpecMistralApiKey {
  /**
   * @schema AiServiceSpecMistralApiKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecMistralApiKey' to JSON representation.
 */
 
export function toJson_AiServiceSpecMistralApiKey(obj: AiServiceSpecMistralApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecMistralParams
 */
export interface AiServiceSpecMistralParams {
  /**
   * @schema AiServiceSpecMistralParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecMistralParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecMistralParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecMistralParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecMistralParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecMistralParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecMistralParams(obj: AiServiceSpecMistralParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecOllamaParams
 */
export interface AiServiceSpecOllamaParams {
  /**
   * @schema AiServiceSpecOllamaParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecOllamaParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecOllamaParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecOllamaParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecOllamaParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecOllamaParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecOllamaParams(obj: AiServiceSpecOllamaParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecOpenaiParams
 */
export interface AiServiceSpecOpenaiParams {
  /**
   * @schema AiServiceSpecOpenaiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecOpenaiParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecOpenaiParams(obj: AiServiceSpecOpenaiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecOpenaiToken
 */
export interface AiServiceSpecOpenaiToken {
  /**
   * @schema AiServiceSpecOpenaiToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecOpenaiToken' to JSON representation.
 */
 
export function toJson_AiServiceSpecOpenaiToken(obj: AiServiceSpecOpenaiToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecQWenParams
 */
export interface AiServiceSpecQWenParams {
  /**
   * @schema AiServiceSpecQWenParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecQWenParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecQWenParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecQWenParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecQWenParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecQWenParams' to JSON representation.
 */
 
export function toJson_AiServiceSpecQWenParams(obj: AiServiceSpecQWenParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * SecretReference references a kubernetes secret.
 *
 * @schema AiServiceSpecQWenToken
 */
export interface AiServiceSpecQWenToken {
  /**
   * @schema AiServiceSpecQWenToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'AiServiceSpecQWenToken' to JSON representation.
 */
 
export function toJson_AiServiceSpecQWenToken(obj: AiServiceSpecQWenToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'secretName': obj.secretName,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * API defines an HTTP interface that is exposed to external clients. It specifies the supported versions
and provides instructions for accessing its documentation. Once instantiated, an API object is associated
with an Ingress, IngressRoute, or HTTPRoute resource, enabling the exposure of the described API to the outside world.
 *
 * @schema API
 */
export class Api extends ApiObject {
  /**
   * Returns the apiVersion and kind for "API"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'API',
  }

  /**
   * Renders a Kubernetes manifest for "API".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiProps = {}): any {
    return {
      ...Api.GVK,
      ...toJson_ApiProps(props),
    }
  }

  /**
   * Defines a "API" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiProps = {}) {
    super(scope, id, {
      ...Api.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...Api.GVK,
      ...toJson_ApiProps(resolved),
    }
  }
}

/**
 * API defines an HTTP interface that is exposed to external clients. It specifies the supported versions
 * and provides instructions for accessing its documentation. Once instantiated, an API object is associated
 * with an Ingress, IngressRoute, or HTTPRoute resource, enabling the exposure of the described API to the outside world.
 *
 * @schema API
 */
export interface ApiProps {
  /**
   * @schema API#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APISpec describes the API.
   *
   * @schema API#spec
   */
  readonly spec?: ApiSpec;

}

/**
 * Converts an object of type 'ApiProps' to JSON representation.
 */
 
export function toJson_ApiProps(obj: ApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APISpec describes the API.
 *
 * @schema ApiSpec
 */
export interface ApiSpec {
  /**
   * Cors defines the Cross-Origin Resource Sharing configuration.
   *
   * @schema ApiSpec#cors
   */
  readonly cors?: ApiSpecCors;

  /**
   * Description explains what the API does.
   *
   * @schema ApiSpec#description
   */
  readonly description?: string;

  /**
   * OpenAPISpec defines the API contract as an OpenAPI specification.
   *
   * @schema ApiSpec#openApiSpec
   */
  readonly openApiSpec?: ApiSpecOpenApiSpec;

  /**
   * Title is the human-readable name of the API that will be used on the portal.
   *
   * @schema ApiSpec#title
   */
  readonly title?: string;

  /**
   * Versions are the different APIVersions available.
   *
   * @schema ApiSpec#versions
   */
  readonly versions?: ApiSpecVersions[];

}

/**
 * Converts an object of type 'ApiSpec' to JSON representation.
 */
 
export function toJson_ApiSpec(obj: ApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'cors': toJson_ApiSpecCors(obj.cors),
    'description': obj.description,
    'openApiSpec': toJson_ApiSpecOpenApiSpec(obj.openApiSpec),
    'title': obj.title,
    'versions': obj.versions?.map((y) => toJson_ApiSpecVersions(y)),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Cors defines the Cross-Origin Resource Sharing configuration.
 *
 * @schema ApiSpecCors
 */
export interface ApiSpecCors {
  /**
   * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
   *
   * @schema ApiSpecCors#addVaryHeader
   */
  readonly addVaryHeader?: boolean;

  /**
   * AllowCredentials defines whether the request can include user credentials.
   *
   * @schema ApiSpecCors#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
   *
   * @schema ApiSpecCors#allowHeadersList
   */
  readonly allowHeadersList?: string[];

  /**
   * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
   *
   * @schema ApiSpecCors#allowMethodsList
   */
  readonly allowMethodsList?: string[];

  /**
   * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
   *
   * @schema ApiSpecCors#allowOriginListRegex
   */
  readonly allowOriginListRegex?: string[];

  /**
   * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
   *
   * @schema ApiSpecCors#allowOriginsList
   */
  readonly allowOriginsList?: string[];

  /**
   * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
   *
   * @schema ApiSpecCors#exposeHeadersList
   */
  readonly exposeHeadersList?: string[];

  /**
   * MaxAge defines the time that a preflight request may be cached.
   *
   * @schema ApiSpecCors#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ApiSpecCors' to JSON representation.
 */
 
export function toJson_ApiSpecCors(obj: ApiSpecCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'addVaryHeader': obj.addVaryHeader,
    'allowCredentials': obj.allowCredentials,
    'allowHeadersList': obj.allowHeadersList?.map((y) => y),
    'allowMethodsList': obj.allowMethodsList?.map((y) => y),
    'allowOriginListRegex': obj.allowOriginListRegex?.map((y) => y),
    'allowOriginsList': obj.allowOriginsList?.map((y) => y),
    'exposeHeadersList': obj.exposeHeadersList?.map((y) => y),
    'maxAge': obj.maxAge,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OpenAPISpec defines the API contract as an OpenAPI specification.
 *
 * @schema ApiSpecOpenApiSpec
 */
export interface ApiSpecOpenApiSpec {
  /**
   * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
   *
   * @schema ApiSpecOpenApiSpec#operationSets
   */
  readonly operationSets?: ApiSpecOpenApiSpecOperationSets[];

  /**
   * Override holds data used to override OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#override
   */
  readonly override?: ApiSpecOpenApiSpecOverride;

  /**
   * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
   * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
   * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
   * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#path
   */
  readonly path?: string;

  /**
   * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
   * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#url
   */
  readonly url?: string;

  /**
   * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
   * This option overrides the default behavior configured in the static configuration.
   *
   * @schema ApiSpecOpenApiSpec#validateRequestMethodAndPath
   */
  readonly validateRequestMethodAndPath?: boolean;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpec' to JSON representation.
 */
 
export function toJson_ApiSpecOpenApiSpec(obj: ApiSpecOpenApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'operationSets': obj.operationSets?.map((y) => toJson_ApiSpecOpenApiSpecOperationSets(y)),
    'override': toJson_ApiSpecOpenApiSpecOverride(obj.override),
    'path': obj.path,
    'url': obj.url,
    'validateRequestMethodAndPath': obj.validateRequestMethodAndPath,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIVersionRef references an APIVersion.
 *
 * @schema ApiSpecVersions
 */
export interface ApiSpecVersions {
  /**
   * Name of the APIVersion.
   *
   * @schema ApiSpecVersions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecVersions' to JSON representation.
 */
 
export function toJson_ApiSpecVersions(obj: ApiSpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationSet gives a name to a set of matching OpenAPI operations.
 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
 *
 * @schema ApiSpecOpenApiSpecOperationSets
 */
export interface ApiSpecOpenApiSpecOperationSets {
  /**
   * Matchers defines a list of alternative rules for matching OpenAPI operations.
   *
   * @schema ApiSpecOpenApiSpecOperationSets#matchers
   */
  readonly matchers: ApiSpecOpenApiSpecOperationSetsMatchers[];

  /**
   * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
   *
   * @schema ApiSpecOpenApiSpecOperationSets#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOperationSets' to JSON representation.
 */
 
export function toJson_ApiSpecOpenApiSpecOperationSets(obj: ApiSpecOpenApiSpecOperationSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchers': obj.matchers?.map((y) => toJson_ApiSpecOpenApiSpecOperationSetsMatchers(y)),
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Override holds data used to override OpenAPI specification.
 *
 * @schema ApiSpecOpenApiSpecOverride
 */
export interface ApiSpecOpenApiSpecOverride {
  /**
   * @schema ApiSpecOpenApiSpecOverride#servers
   */
  readonly servers: ApiSpecOpenApiSpecOverrideServers[];

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOverride' to JSON representation.
 */
 
export function toJson_ApiSpecOpenApiSpecOverride(obj: ApiSpecOpenApiSpecOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'servers': obj.servers?.map((y) => toJson_ApiSpecOpenApiSpecOverrideServers(y)),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationMatcher defines criteria for matching an OpenAPI operation.
 *
 * @schema ApiSpecOpenApiSpecOperationSetsMatchers
 */
export interface ApiSpecOpenApiSpecOperationSetsMatchers {
  /**
   * Methods specifies the HTTP methods to be included for selection.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#methods
   */
  readonly methods?: string[];

  /**
   * Path specifies the exact path of the operations to select.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#path
   */
  readonly path?: string;

  /**
   * PathPrefix specifies the path prefix of the operations to select.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * PathRegex specifies a regular expression pattern for matching operations based on their paths.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#pathRegex
   */
  readonly pathRegex?: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOperationSetsMatchers' to JSON representation.
 */
 
export function toJson_ApiSpecOpenApiSpecOperationSetsMatchers(obj: ApiSpecOpenApiSpecOperationSetsMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'methods': obj.methods?.map((y) => y),
    'path': obj.path,
    'pathPrefix': obj.pathPrefix,
    'pathRegex': obj.pathRegex,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * @schema ApiSpecOpenApiSpecOverrideServers
 */
export interface ApiSpecOpenApiSpecOverrideServers {
  /**
   * @schema ApiSpecOpenApiSpecOverrideServers#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOverrideServers' to JSON representation.
 */
 
export function toJson_ApiSpecOpenApiSpecOverrideServers(obj: ApiSpecOpenApiSpecOverrideServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'url': obj.url,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APIBundle defines a set of APIs.
 *
 * @schema APIBundle
 */
export class ApiBundle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIBundle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIBundle',
  }

  /**
   * Renders a Kubernetes manifest for "APIBundle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiBundleProps = {}): any {
    return {
      ...ApiBundle.GVK,
      ...toJson_ApiBundleProps(props),
    }
  }

  /**
   * Defines a "APIBundle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiBundleProps = {}) {
    super(scope, id, {
      ...ApiBundle.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiBundle.GVK,
      ...toJson_ApiBundleProps(resolved),
    }
  }
}

/**
 * APIBundle defines a set of APIs.
 *
 * @schema APIBundle
 */
export interface ApiBundleProps {
  /**
   * @schema APIBundle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIBundle.
   *
   * @schema APIBundle#spec
   */
  readonly spec?: ApiBundleSpec;

}

/**
 * Converts an object of type 'ApiBundleProps' to JSON representation.
 */
 
export function toJson_ApiBundleProps(obj: ApiBundleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiBundleSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APIBundle.
 *
 * @schema ApiBundleSpec
 */
export interface ApiBundleSpec {
  /**
   * APISelector selects the APIs that will be accessible to the configured audience.
   * Multiple APIBundles can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiBundleSpec#apiSelector
   */
  readonly apiSelector?: ApiBundleSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be accessible to the configured audience.
   * Multiple APIBundles can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiBundleSpec#apis
   */
  readonly apis?: ApiBundleSpecApis[];

  /**
   * Title is the human-readable name of the APIBundle that will be used on the portal.
   *
   * @schema ApiBundleSpec#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ApiBundleSpec' to JSON representation.
 */
 
export function toJson_ApiBundleSpec(obj: ApiBundleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiSelector': toJson_ApiBundleSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map((y) => toJson_ApiBundleSpecApis(y)),
    'title': obj.title,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APISelector selects the APIs that will be accessible to the configured audience.
 * Multiple APIBundles can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiBundleSpecApiSelector
 */
export interface ApiBundleSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiBundleSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiBundleSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiBundleSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiBundleSpecApiSelector' to JSON representation.
 */
 
export function toJson_ApiBundleSpecApiSelector(obj: ApiBundleSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchExpressions': obj.matchExpressions?.map((y) => toJson_ApiBundleSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIReference references an API.
 *
 * @schema ApiBundleSpecApis
 */
export interface ApiBundleSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiBundleSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiBundleSpecApis' to JSON representation.
 */
 
export function toJson_ApiBundleSpecApis(obj: ApiBundleSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiBundleSpecApiSelectorMatchExpressions
 */
export interface ApiBundleSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiBundleSpecApiSelectorMatchExpressions' to JSON representation.
 */
 
export function toJson_ApiBundleSpecApiSelectorMatchExpressions(obj: ApiBundleSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APICatalogItem defines APIs that will be part of the API catalog on the portal.
 *
 * @schema APICatalogItem
 */
export class ApiCatalogItem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APICatalogItem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APICatalogItem',
  }

  /**
   * Renders a Kubernetes manifest for "APICatalogItem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiCatalogItemProps = {}): any {
    return {
      ...ApiCatalogItem.GVK,
      ...toJson_ApiCatalogItemProps(props),
    }
  }

  /**
   * Defines a "APICatalogItem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiCatalogItemProps = {}) {
    super(scope, id, {
      ...ApiCatalogItem.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiCatalogItem.GVK,
      ...toJson_ApiCatalogItemProps(resolved),
    }
  }
}

/**
 * APICatalogItem defines APIs that will be part of the API catalog on the portal.
 *
 * @schema APICatalogItem
 */
export interface ApiCatalogItemProps {
  /**
   * @schema APICatalogItem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APICatalogItem.
   *
   * @schema APICatalogItem#spec
   */
  readonly spec?: ApiCatalogItemSpec;

}

/**
 * Converts an object of type 'ApiCatalogItemProps' to JSON representation.
 */
 
export function toJson_ApiCatalogItemProps(obj: ApiCatalogItemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiCatalogItemSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APICatalogItem.
 *
 * @schema ApiCatalogItemSpec
 */
export interface ApiCatalogItemSpec {
  /**
   * APIBundles defines a set of APIBundle that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same APIBundles.
   *
   * @schema ApiCatalogItemSpec#apiBundles
   */
  readonly apiBundles?: ApiCatalogItemSpecApiBundles[];

  /**
   * APIPlan defines which APIPlan will be available.
   * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
   * a plan from this list.
   *
   * @schema ApiCatalogItemSpec#apiPlan
   */
  readonly apiPlan?: ApiCatalogItemSpecApiPlan;

  /**
   * APISelector selects the APIs that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiCatalogItemSpec#apiSelector
   */
  readonly apiSelector?: ApiCatalogItemSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiCatalogItemSpec#apis
   */
  readonly apis?: ApiCatalogItemSpecApis[];

  /**
   * Everyone indicates that all users will see these APIs.
   *
   * @schema ApiCatalogItemSpec#everyone
   */
  readonly everyone?: boolean;

  /**
   * Groups are the consumer groups that will see the APIs.
   *
   * @schema ApiCatalogItemSpec#groups
   */
  readonly groups?: string[];

  /**
   * OperationFilter specifies the visible operations on APIs and APIVersions.
   * If not set, all operations are available.
   * An empty OperationFilter prohibits all operations.
   *
   * @schema ApiCatalogItemSpec#operationFilter
   */
  readonly operationFilter?: ApiCatalogItemSpecOperationFilter;

}

/**
 * Converts an object of type 'ApiCatalogItemSpec' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpec(obj: ApiCatalogItemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiBundles': obj.apiBundles?.map((y) => toJson_ApiCatalogItemSpecApiBundles(y)),
    'apiPlan': toJson_ApiCatalogItemSpecApiPlan(obj.apiPlan),
    'apiSelector': toJson_ApiCatalogItemSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map((y) => toJson_ApiCatalogItemSpecApis(y)),
    'everyone': obj.everyone,
    'groups': obj.groups?.map((y) => y),
    'operationFilter': toJson_ApiCatalogItemSpecOperationFilter(obj.operationFilter),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIBundleReference references an APIBundle.
 *
 * @schema ApiCatalogItemSpecApiBundles
 */
export interface ApiCatalogItemSpecApiBundles {
  /**
   * Name of the APIBundle.
   *
   * @schema ApiCatalogItemSpecApiBundles#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiBundles' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecApiBundles(obj: ApiCatalogItemSpecApiBundles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIPlan defines which APIPlan will be available.
 * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
 * a plan from this list.
 *
 * @schema ApiCatalogItemSpecApiPlan
 */
export interface ApiCatalogItemSpecApiPlan {
  /**
   * Name of the APIPlan.
   *
   * @schema ApiCatalogItemSpecApiPlan#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiPlan' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecApiPlan(obj: ApiCatalogItemSpecApiPlan | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APISelector selects the APIs that will be visible to the configured audience.
 * Multiple APICatalogItem can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiCatalogItemSpecApiSelector
 */
export interface ApiCatalogItemSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiCatalogItemSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiCatalogItemSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiCatalogItemSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiSelector' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecApiSelector(obj: ApiCatalogItemSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchExpressions': obj.matchExpressions?.map((y) => toJson_ApiCatalogItemSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIReference references an API.
 *
 * @schema ApiCatalogItemSpecApis
 */
export interface ApiCatalogItemSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiCatalogItemSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApis' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecApis(obj: ApiCatalogItemSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationFilter specifies the visible operations on APIs and APIVersions.
 * If not set, all operations are available.
 * An empty OperationFilter prohibits all operations.
 *
 * @schema ApiCatalogItemSpecOperationFilter
 */
export interface ApiCatalogItemSpecOperationFilter {
  /**
   * Include defines the names of OperationSets that will be accessible.
   *
   * @schema ApiCatalogItemSpecOperationFilter#include
   */
  readonly include?: string[];

}

/**
 * Converts an object of type 'ApiCatalogItemSpecOperationFilter' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecOperationFilter(obj: ApiCatalogItemSpecOperationFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'include': obj.include?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiCatalogItemSpecApiSelectorMatchExpressions
 */
export interface ApiCatalogItemSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiSelectorMatchExpressions' to JSON representation.
 */
 
export function toJson_ApiCatalogItemSpecApiSelectorMatchExpressions(obj: ApiCatalogItemSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APIPlan defines API Plan policy.
 *
 * @schema APIPlan
 */
export class ApiPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIPlan',
  }

  /**
   * Renders a Kubernetes manifest for "APIPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiPlanProps = {}): any {
    return {
      ...ApiPlan.GVK,
      ...toJson_ApiPlanProps(props),
    }
  }

  /**
   * Defines a "APIPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiPlanProps = {}) {
    super(scope, id, {
      ...ApiPlan.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiPlan.GVK,
      ...toJson_ApiPlanProps(resolved),
    }
  }
}

/**
 * APIPlan defines API Plan policy.
 *
 * @schema APIPlan
 */
export interface ApiPlanProps {
  /**
   * @schema APIPlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIPlan.
   *
   * @schema APIPlan#spec
   */
  readonly spec?: ApiPlanSpec;

}

/**
 * Converts an object of type 'ApiPlanProps' to JSON representation.
 */
 
export function toJson_ApiPlanProps(obj: ApiPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiPlanSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APIPlan.
 *
 * @schema ApiPlanSpec
 */
export interface ApiPlanSpec {
  /**
   * Description describes the plan.
   *
   * @schema ApiPlanSpec#description
   */
  readonly description?: string;

  /**
   * Quota defines the quota policy.
   *
   * @schema ApiPlanSpec#quota
   */
  readonly quota?: ApiPlanSpecQuota;

  /**
   * RateLimit defines the rate limit policy.
   *
   * @schema ApiPlanSpec#rateLimit
   */
  readonly rateLimit?: ApiPlanSpecRateLimit;

  /**
   * Title is the human-readable name of the plan.
   *
   * @schema ApiPlanSpec#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'ApiPlanSpec' to JSON representation.
 */
 
export function toJson_ApiPlanSpec(obj: ApiPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'description': obj.description,
    'quota': toJson_ApiPlanSpecQuota(obj.quota),
    'rateLimit': toJson_ApiPlanSpecRateLimit(obj.rateLimit),
    'title': obj.title,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Quota defines the quota policy.
 *
 * @schema ApiPlanSpecQuota
 */
export interface ApiPlanSpecQuota {
  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiPlanSpecQuota#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiPlanSpecQuota#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'ApiPlanSpecQuota' to JSON representation.
 */
 
export function toJson_ApiPlanSpecQuota(obj: ApiPlanSpecQuota | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'limit': obj.limit,
    'period': obj.period,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * RateLimit defines the rate limit policy.
 *
 * @schema ApiPlanSpecRateLimit
 */
export interface ApiPlanSpecRateLimit {
  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiPlanSpecRateLimit#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiPlanSpecRateLimit#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'ApiPlanSpecRateLimit' to JSON representation.
 */
 
export function toJson_ApiPlanSpecRateLimit(obj: ApiPlanSpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'limit': obj.limit,
    'period': obj.period,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APIPortal defines a developer portal for accessing the documentation of APIs.
 *
 * @schema APIPortal
 */
export class ApiPortal extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIPortal"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIPortal',
  }

  /**
   * Renders a Kubernetes manifest for "APIPortal".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiPortalProps = {}): any {
    return {
      ...ApiPortal.GVK,
      ...toJson_ApiPortalProps(props),
    }
  }

  /**
   * Defines a "APIPortal" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiPortalProps = {}) {
    super(scope, id, {
      ...ApiPortal.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiPortal.GVK,
      ...toJson_ApiPortalProps(resolved),
    }
  }
}

/**
 * APIPortal defines a developer portal for accessing the documentation of APIs.
 *
 * @schema APIPortal
 */
export interface ApiPortalProps {
  /**
   * @schema APIPortal#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIPortal.
   *
   * @schema APIPortal#spec
   */
  readonly spec?: ApiPortalSpec;

}

/**
 * Converts an object of type 'ApiPortalProps' to JSON representation.
 */
 
export function toJson_ApiPortalProps(obj: ApiPortalProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiPortalSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APIPortal.
 *
 * @schema ApiPortalSpec
 */
export interface ApiPortalSpec {
  /**
   * Description of the APIPortal.
   *
   * @schema ApiPortalSpec#description
   */
  readonly description?: string;

  /**
   * Title is the public facing name of the APIPortal.
   *
   * @schema ApiPortalSpec#title
   */
  readonly title?: string;

  /**
   * TrustedURLs are the urls that are trusted by the OAuth 2.0 authorization server.
   *
   * @schema ApiPortalSpec#trustedUrls
   */
  readonly trustedUrls: string[];

  /**
   * UI holds the UI customization options.
   *
   * @schema ApiPortalSpec#ui
   */
  readonly ui?: ApiPortalSpecUi;

}

/**
 * Converts an object of type 'ApiPortalSpec' to JSON representation.
 */
 
export function toJson_ApiPortalSpec(obj: ApiPortalSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'description': obj.description,
    'title': obj.title,
    'trustedUrls': obj.trustedUrls?.map((y) => y),
    'ui': toJson_ApiPortalSpecUi(obj.ui),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * UI holds the UI customization options.
 *
 * @schema ApiPortalSpecUi
 */
export interface ApiPortalSpecUi {
  /**
   * LogoURL is the public URL of the logo.
   *
   * @schema ApiPortalSpecUi#logoUrl
   */
  readonly logoUrl?: string;

}

/**
 * Converts an object of type 'ApiPortalSpecUi' to JSON representation.
 */
 
export function toJson_ApiPortalSpecUi(obj: ApiPortalSpecUi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'logoUrl': obj.logoUrl,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APIRateLimit defines how group of consumers are rate limited on a set of APIs.
 *
 * @schema APIRateLimit
 */
export class ApiRateLimit extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIRateLimit"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIRateLimit',
  }

  /**
   * Renders a Kubernetes manifest for "APIRateLimit".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiRateLimitProps = {}): any {
    return {
      ...ApiRateLimit.GVK,
      ...toJson_ApiRateLimitProps(props),
    }
  }

  /**
   * Defines a "APIRateLimit" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiRateLimitProps = {}) {
    super(scope, id, {
      ...ApiRateLimit.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiRateLimit.GVK,
      ...toJson_ApiRateLimitProps(resolved),
    }
  }
}

/**
 * APIRateLimit defines how group of consumers are rate limited on a set of APIs.
 *
 * @schema APIRateLimit
 */
export interface ApiRateLimitProps {
  /**
   * @schema APIRateLimit#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIRateLimit.
   *
   * @schema APIRateLimit#spec
   */
  readonly spec?: ApiRateLimitSpec;

}

/**
 * Converts an object of type 'ApiRateLimitProps' to JSON representation.
 */
 
export function toJson_ApiRateLimitProps(obj: ApiRateLimitProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiRateLimitSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APIRateLimit.
 *
 * @schema ApiRateLimitSpec
 */
export interface ApiRateLimitSpec {
  /**
   * APISelector selects the APIs that will be rate limited.
   * Multiple APIRateLimits can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiRateLimitSpec#apiSelector
   */
  readonly apiSelector?: ApiRateLimitSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be rate limited.
   * Multiple APIRateLimits can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiRateLimitSpec#apis
   */
  readonly apis?: ApiRateLimitSpecApis[];

  /**
   * Everyone indicates that all users will, by default, be rate limited with this configuration.
   * If an APIRateLimit explicitly target a group, the default rate limit will be ignored.
   *
   * @schema ApiRateLimitSpec#everyone
   */
  readonly everyone?: boolean;

  /**
   * Groups are the consumer groups that will be rate limited.
   * Multiple APIRateLimits can target the same set of consumer groups, the most restrictive one applies.
   * When a consumer belongs to multiple groups, the least restrictive APIRateLimit applies.
   *
   * @schema ApiRateLimitSpec#groups
   */
  readonly groups?: string[];

  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiRateLimitSpec#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiRateLimitSpec#period
   */
  readonly period?: string;

  /**
   * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
   * It can be, either "local" or "distributed".
   *
   * @schema ApiRateLimitSpec#strategy
   */
  readonly strategy?: ApiRateLimitSpecStrategy;

}

/**
 * Converts an object of type 'ApiRateLimitSpec' to JSON representation.
 */
 
export function toJson_ApiRateLimitSpec(obj: ApiRateLimitSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiSelector': toJson_ApiRateLimitSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map((y) => toJson_ApiRateLimitSpecApis(y)),
    'everyone': obj.everyone,
    'groups': obj.groups?.map((y) => y),
    'limit': obj.limit,
    'period': obj.period,
    'strategy': obj.strategy,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APISelector selects the APIs that will be rate limited.
 * Multiple APIRateLimits can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiRateLimitSpecApiSelector
 */
export interface ApiRateLimitSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiRateLimitSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiRateLimitSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiRateLimitSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiRateLimitSpecApiSelector' to JSON representation.
 */
 
export function toJson_ApiRateLimitSpecApiSelector(obj: ApiRateLimitSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchExpressions': obj.matchExpressions?.map((y) => toJson_ApiRateLimitSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIReference references an API.
 *
 * @schema ApiRateLimitSpecApis
 */
export interface ApiRateLimitSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiRateLimitSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiRateLimitSpecApis' to JSON representation.
 */
 
export function toJson_ApiRateLimitSpecApis(obj: ApiRateLimitSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
 * It can be, either "local" or "distributed".
 *
 * @schema ApiRateLimitSpecStrategy
 */
export enum ApiRateLimitSpecStrategy {
  /** local */
  LOCAL = "local",
  /** distributed */
  DISTRIBUTED = "distributed",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiRateLimitSpecApiSelectorMatchExpressions
 */
export interface ApiRateLimitSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiRateLimitSpecApiSelectorMatchExpressions' to JSON representation.
 */
 
export function toJson_ApiRateLimitSpecApiSelectorMatchExpressions(obj: ApiRateLimitSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * APIVersion defines a version of an API.
 *
 * @schema APIVersion
 */
export class ApiVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIVersion',
  }

  /**
   * Renders a Kubernetes manifest for "APIVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiVersionProps = {}): any {
    return {
      ...ApiVersion.GVK,
      ...toJson_ApiVersionProps(props),
    }
  }

  /**
   * Defines a "APIVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiVersionProps = {}) {
    super(scope, id, {
      ...ApiVersion.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ApiVersion.GVK,
      ...toJson_ApiVersionProps(resolved),
    }
  }
}

/**
 * APIVersion defines a version of an API.
 *
 * @schema APIVersion
 */
export interface ApiVersionProps {
  /**
   * @schema APIVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIVersion.
   *
   * @schema APIVersion#spec
   */
  readonly spec?: ApiVersionSpec;

}

/**
 * Converts an object of type 'ApiVersionProps' to JSON representation.
 */
 
export function toJson_ApiVersionProps(obj: ApiVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiVersionSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this APIVersion.
 *
 * @schema ApiVersionSpec
 */
export interface ApiVersionSpec {
  /**
   * Cors defines the Cross-Origin Resource Sharing configuration.
   *
   * @schema ApiVersionSpec#cors
   */
  readonly cors?: ApiVersionSpecCors;

  /**
   * Description explains what the APIVersion does.
   *
   * @schema ApiVersionSpec#description
   */
  readonly description?: string;

  /**
   * OpenAPISpec defines the API contract as an OpenAPI specification.
   *
   * @schema ApiVersionSpec#openApiSpec
   */
  readonly openApiSpec?: ApiVersionSpecOpenApiSpec;

  /**
   * Release is the version number of the API.
   * This value must follow the SemVer format: https://semver.org/
   *
   * @schema ApiVersionSpec#release
   */
  readonly release: string;

  /**
   * Title is the public facing name of the APIVersion.
   *
   * @schema ApiVersionSpec#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ApiVersionSpec' to JSON representation.
 */
 
export function toJson_ApiVersionSpec(obj: ApiVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'cors': toJson_ApiVersionSpecCors(obj.cors),
    'description': obj.description,
    'openApiSpec': toJson_ApiVersionSpecOpenApiSpec(obj.openApiSpec),
    'release': obj.release,
    'title': obj.title,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Cors defines the Cross-Origin Resource Sharing configuration.
 *
 * @schema ApiVersionSpecCors
 */
export interface ApiVersionSpecCors {
  /**
   * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
   *
   * @schema ApiVersionSpecCors#addVaryHeader
   */
  readonly addVaryHeader?: boolean;

  /**
   * AllowCredentials defines whether the request can include user credentials.
   *
   * @schema ApiVersionSpecCors#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
   *
   * @schema ApiVersionSpecCors#allowHeadersList
   */
  readonly allowHeadersList?: string[];

  /**
   * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
   *
   * @schema ApiVersionSpecCors#allowMethodsList
   */
  readonly allowMethodsList?: string[];

  /**
   * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
   *
   * @schema ApiVersionSpecCors#allowOriginListRegex
   */
  readonly allowOriginListRegex?: string[];

  /**
   * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
   *
   * @schema ApiVersionSpecCors#allowOriginsList
   */
  readonly allowOriginsList?: string[];

  /**
   * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
   *
   * @schema ApiVersionSpecCors#exposeHeadersList
   */
  readonly exposeHeadersList?: string[];

  /**
   * MaxAge defines the time that a preflight request may be cached.
   *
   * @schema ApiVersionSpecCors#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ApiVersionSpecCors' to JSON representation.
 */
 
export function toJson_ApiVersionSpecCors(obj: ApiVersionSpecCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'addVaryHeader': obj.addVaryHeader,
    'allowCredentials': obj.allowCredentials,
    'allowHeadersList': obj.allowHeadersList?.map((y) => y),
    'allowMethodsList': obj.allowMethodsList?.map((y) => y),
    'allowOriginListRegex': obj.allowOriginListRegex?.map((y) => y),
    'allowOriginsList': obj.allowOriginsList?.map((y) => y),
    'exposeHeadersList': obj.exposeHeadersList?.map((y) => y),
    'maxAge': obj.maxAge,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OpenAPISpec defines the API contract as an OpenAPI specification.
 *
 * @schema ApiVersionSpecOpenApiSpec
 */
export interface ApiVersionSpecOpenApiSpec {
  /**
   * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
   *
   * @schema ApiVersionSpecOpenApiSpec#operationSets
   */
  readonly operationSets?: ApiVersionSpecOpenApiSpecOperationSets[];

  /**
   * Override holds data used to override OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#override
   */
  readonly override?: ApiVersionSpecOpenApiSpecOverride;

  /**
   * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
   * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
   * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
   * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#path
   */
  readonly path?: string;

  /**
   * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
   * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#url
   */
  readonly url?: string;

  /**
   * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
   * This option overrides the default behavior configured in the static configuration.
   *
   * @schema ApiVersionSpecOpenApiSpec#validateRequestMethodAndPath
   */
  readonly validateRequestMethodAndPath?: boolean;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpec' to JSON representation.
 */
 
export function toJson_ApiVersionSpecOpenApiSpec(obj: ApiVersionSpecOpenApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'operationSets': obj.operationSets?.map((y) => toJson_ApiVersionSpecOpenApiSpecOperationSets(y)),
    'override': toJson_ApiVersionSpecOpenApiSpecOverride(obj.override),
    'path': obj.path,
    'url': obj.url,
    'validateRequestMethodAndPath': obj.validateRequestMethodAndPath,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationSet gives a name to a set of matching OpenAPI operations.
 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
 *
 * @schema ApiVersionSpecOpenApiSpecOperationSets
 */
export interface ApiVersionSpecOpenApiSpecOperationSets {
  /**
   * Matchers defines a list of alternative rules for matching OpenAPI operations.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSets#matchers
   */
  readonly matchers: ApiVersionSpecOpenApiSpecOperationSetsMatchers[];

  /**
   * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSets#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOperationSets' to JSON representation.
 */
 
export function toJson_ApiVersionSpecOpenApiSpecOperationSets(obj: ApiVersionSpecOpenApiSpecOperationSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchers': obj.matchers?.map((y) => toJson_ApiVersionSpecOpenApiSpecOperationSetsMatchers(y)),
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * Override holds data used to override OpenAPI specification.
 *
 * @schema ApiVersionSpecOpenApiSpecOverride
 */
export interface ApiVersionSpecOpenApiSpecOverride {
  /**
   * @schema ApiVersionSpecOpenApiSpecOverride#servers
   */
  readonly servers: ApiVersionSpecOpenApiSpecOverrideServers[];

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOverride' to JSON representation.
 */
 
export function toJson_ApiVersionSpecOpenApiSpecOverride(obj: ApiVersionSpecOpenApiSpecOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'servers': obj.servers?.map((y) => toJson_ApiVersionSpecOpenApiSpecOverrideServers(y)),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationMatcher defines criteria for matching an OpenAPI operation.
 *
 * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers
 */
export interface ApiVersionSpecOpenApiSpecOperationSetsMatchers {
  /**
   * Methods specifies the HTTP methods to be included for selection.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#methods
   */
  readonly methods?: string[];

  /**
   * Path specifies the exact path of the operations to select.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#path
   */
  readonly path?: string;

  /**
   * PathPrefix specifies the path prefix of the operations to select.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * PathRegex specifies a regular expression pattern for matching operations based on their paths.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#pathRegex
   */
  readonly pathRegex?: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOperationSetsMatchers' to JSON representation.
 */
 
export function toJson_ApiVersionSpecOpenApiSpecOperationSetsMatchers(obj: ApiVersionSpecOpenApiSpecOperationSetsMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'methods': obj.methods?.map((y) => y),
    'path': obj.path,
    'pathPrefix': obj.pathPrefix,
    'pathRegex': obj.pathRegex,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * @schema ApiVersionSpecOpenApiSpecOverrideServers
 */
export interface ApiVersionSpecOpenApiSpecOverrideServers {
  /**
   * @schema ApiVersionSpecOpenApiSpecOverrideServers#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOverrideServers' to JSON representation.
 */
 
export function toJson_ApiVersionSpecOpenApiSpecOverrideServers(obj: ApiVersionSpecOpenApiSpecOverrideServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'url': obj.url,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 


/**
 * ManagedSubscription defines a Subscription managed by the API manager as the result of a pre-negotiation with its
API consumers. This subscription grant consuming access to a set of APIs to a set of Applications.
 *
 * @schema ManagedSubscription
 */
export class ManagedSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'ManagedSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedSubscriptionProps = {}): any {
    return {
      ...ManagedSubscription.GVK,
      ...toJson_ManagedSubscriptionProps(props),
    }
  }

  /**
   * Defines a "ManagedSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedSubscriptionProps = {}) {
    super(scope, id, {
      ...ManagedSubscription.GVK,
      ...props,
    })
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson()

    return {
      ...ManagedSubscription.GVK,
      ...toJson_ManagedSubscriptionProps(resolved),
    }
  }
}

/**
 * ManagedSubscription defines a Subscription managed by the API manager as the result of a pre-negotiation with its
 * API consumers. This subscription grant consuming access to a set of APIs to a set of Applications.
 *
 * @schema ManagedSubscription
 */
export interface ManagedSubscriptionProps {
  /**
   * @schema ManagedSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this ManagedSubscription.
   *
   * @schema ManagedSubscription#spec
   */
  readonly spec?: ManagedSubscriptionSpec;

}

/**
 * Converts an object of type 'ManagedSubscriptionProps' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionProps(obj: ManagedSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedSubscriptionSpec(obj.spec),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * The desired behavior of this ManagedSubscription.
 *
 * @schema ManagedSubscriptionSpec
 */
export interface ManagedSubscriptionSpec {
  /**
   * APIBundles defines a set of APIBundle that will be accessible.
   * Multiple ManagedSubscriptions can select the same APIBundles.
   *
   * @schema ManagedSubscriptionSpec#apiBundles
   */
  readonly apiBundles?: ManagedSubscriptionSpecApiBundles[];

  /**
   * APIPlan defines which APIPlan will be used.
   *
   * @schema ManagedSubscriptionSpec#apiPlan
   */
  readonly apiPlan: ManagedSubscriptionSpecApiPlan;

  /**
   * APISelector selects the APIs that will be accessible.
   * Multiple ManagedSubscriptions can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ManagedSubscriptionSpec#apiSelector
   */
  readonly apiSelector?: ManagedSubscriptionSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be accessible.
   * Multiple ManagedSubscriptions can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ManagedSubscriptionSpec#apis
   */
  readonly apis?: ManagedSubscriptionSpecApis[];

  /**
   * Applications references the Applications that will gain access to the specified APIs.
   * Multiple ManagedSubscriptions can select the same AppID.
   *
   * @schema ManagedSubscriptionSpec#applications
   */
  readonly applications: ManagedSubscriptionSpecApplications[];

  /**
   * Claims specifies an expression that validate claims in order to authorize the request.
   *
   * @schema ManagedSubscriptionSpec#claims
   */
  readonly claims?: string;

  /**
   * OperationFilter specifies the allowed operations on APIs and APIVersions.
   * If not set, all operations are available.
   * An empty OperationFilter prohibits all operations.
   *
   * @schema ManagedSubscriptionSpec#operationFilter
   */
  readonly operationFilter?: ManagedSubscriptionSpecOperationFilter;

  /**
   * Weight specifies the evaluation order of the APIPlan.
   * When multiple ManagedSubscriptions targets the same API and Application with different APIPlan,
   * the APIPlan with the highest weight will be enforced. If weights are equal, alphabetical order is used.
   *
   * @schema ManagedSubscriptionSpec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpec' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpec(obj: ManagedSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'apiBundles': obj.apiBundles?.map((y) => toJson_ManagedSubscriptionSpecApiBundles(y)),
    'apiPlan': toJson_ManagedSubscriptionSpecApiPlan(obj.apiPlan),
    'apiSelector': toJson_ManagedSubscriptionSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map((y) => toJson_ManagedSubscriptionSpecApis(y)),
    'applications': obj.applications?.map((y) => toJson_ManagedSubscriptionSpecApplications(y)),
    'claims': obj.claims,
    'operationFilter': toJson_ManagedSubscriptionSpecOperationFilter(obj.operationFilter),
    'weight': obj.weight,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIBundleReference references an APIBundle.
 *
 * @schema ManagedSubscriptionSpecApiBundles
 */
export interface ManagedSubscriptionSpecApiBundles {
  /**
   * Name of the APIBundle.
   *
   * @schema ManagedSubscriptionSpecApiBundles#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiBundles' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApiBundles(obj: ManagedSubscriptionSpecApiBundles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIPlan defines which APIPlan will be used.
 *
 * @schema ManagedSubscriptionSpecApiPlan
 */
export interface ManagedSubscriptionSpecApiPlan {
  /**
   * Name of the APIPlan.
   *
   * @schema ManagedSubscriptionSpecApiPlan#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiPlan' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApiPlan(obj: ManagedSubscriptionSpecApiPlan | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APISelector selects the APIs that will be accessible.
 * Multiple ManagedSubscriptions can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ManagedSubscriptionSpecApiSelector
 */
export interface ManagedSubscriptionSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ManagedSubscriptionSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ManagedSubscriptionSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ManagedSubscriptionSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiSelector' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApiSelector(obj: ManagedSubscriptionSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'matchExpressions': obj.matchExpressions?.map((y) => toJson_ManagedSubscriptionSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * APIReference references an API.
 *
 * @schema ManagedSubscriptionSpecApis
 */
export interface ManagedSubscriptionSpecApis {
  /**
   * Name of the API.
   *
   * @schema ManagedSubscriptionSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApis' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApis(obj: ManagedSubscriptionSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'name': obj.name,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * ApplicationReference references an Application.
 *
 * @schema ManagedSubscriptionSpecApplications
 */
export interface ManagedSubscriptionSpecApplications {
  /**
   * AppID is the public identifier of the application.
   * In the case of OIDC, it corresponds to the clientId.
   *
   * @schema ManagedSubscriptionSpecApplications#appId
   */
  readonly appId: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApplications' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApplications(obj: ManagedSubscriptionSpecApplications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'appId': obj.appId,
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * OperationFilter specifies the allowed operations on APIs and APIVersions.
 * If not set, all operations are available.
 * An empty OperationFilter prohibits all operations.
 *
 * @schema ManagedSubscriptionSpecOperationFilter
 */
export interface ManagedSubscriptionSpecOperationFilter {
  /**
   * Include defines the names of OperationSets that will be accessible.
   *
   * @schema ManagedSubscriptionSpecOperationFilter#include
   */
  readonly include?: string[];

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecOperationFilter' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecOperationFilter(obj: ManagedSubscriptionSpecOperationFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'include': obj.include?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions
 */
export interface ManagedSubscriptionSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiSelectorMatchExpressions' to JSON representation.
 */
 
export function toJson_ManagedSubscriptionSpecApiSelectorMatchExpressions(obj: ManagedSubscriptionSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map((y) => y),
  }
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})
}
 

